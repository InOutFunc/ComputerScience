# 最长有效括号

## 思路

```c++
dp[i]表示以s[i - 1]结尾的最长有效括号数量;
```

## 和`s[i-1]`配对的`s[j]`

```c++
for (int i = 1; i <= n; i++) {
    int j = i - 1 - dp[i - 1] - 1;
}
```

## `dp[i]`为0

```c++
s[i - 1] == '(';
j < 0; //没有匹配的
s[j] == ')';

if (s[i - 1] == '(' || j < 0 || s[j] == ')') {
    dp[i] = 0;
}
```

## 状态转移方程

```c++
else {
    dp[i] = dp[i - 1] + 2 + dp[j];
    res = max(res, dp[i]);
}
```

